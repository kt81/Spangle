using System.Diagnostics.CodeAnalysis;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Spangle.SourceGenerator.Rtmp;

[Generator(LanguageNames.CSharp)]
public class Amf0SerializableGenerator : IIncrementalGenerator
{
    private const string StructAttributeName       = "Amf0SerializableAttribute";
    private const string FieldAttributeName        = "Amf0FieldAttribute";
    private const string FieldAttrPositionPropName = "Position";
    private const string MethodNameToAdd           = "ToAmf0Object";

    private static readonly string s_namespace = typeof(Amf0SerializableGenerator).Namespace;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource($"{StructAttributeName}.g.cs", $$"""
namespace {{s_namespace}};

using System;

[AttributeUsage(AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
internal sealed class {{StructAttributeName}} : Attribute
{
}

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false, Inherited = false)]
internal sealed class {{FieldAttributeName}} : Attribute
{
    public int {{FieldAttrPositionPropName}} { get; private set; }
    public {{FieldAttributeName}}(int {{FieldAttrPositionPropName.ToLowerInvariant()}})
    {
        {{FieldAttrPositionPropName}} = {{FieldAttrPositionPropName.ToLowerInvariant()}};
    }
}
""");
        });

        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            $"{s_namespace}.{StructAttributeName}",
            static (node, _) => node is StructDeclarationSyntax,
            static (context, _) => context);

        context.RegisterSourceOutput(source, Emit);
    }

    private static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        // classで引っ掛けてるのでTypeSymbol/Syntaxとして使えるように。
        // SemaintiModelが欲しい場合は source.SemanticModel
        // Compilationが欲しい場合は source.SemanticModel.Compilation から
        var typeSymbol = (INamedTypeSymbol)source.TargetSymbol;
        var typeNode = (TypeDeclarationSyntax)source.TargetNode;

        if (typeSymbol.GetMembers(MethodNameToAdd).Length != 0)
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.ToAmf0ObjectMethodExists,
                typeNode.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }

        string ns = typeSymbol.ContainingNamespace.IsGlobalNamespace
            ? ""
            : $"namespace {typeSymbol.ContainingNamespace};";

        // 出力ファイル名として使うので雑エスケープ
        string fullType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_")
            .Replace(">", "_");


        // Field/Propertyを抽出する
        var publicMembers = typeSymbol.GetMembers()
            .Where(x => x is (IFieldSymbol or IPropertySymbol)
                and
                {
                    IsStatic: false, DeclaredAccessibility: Accessibility.Public, IsImplicitlyDeclared: false,
                    CanBeReferencedByName: true
                } && x.GetAttributes().Any(attr => attr.AttributeClass?.Name is FieldAttributeName))
            .OrderBy(x =>
                x.GetAttributes().First(attr => attr.AttributeClass?.Name is FieldAttributeName).NamedArguments.First()
                    .Value);

        var serializerPartBuilder = new StringBuilder();
        foreach (ISymbol fieldOrProp in publicMembers)
        {
            string? serializerMethod = DetermineFieldSerializerStr(fieldOrProp);
            if (serializerMethod is null)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.ToAmf0ObjectMethodExists,
                    typeNode.Identifier.GetLocation(), fieldOrProp.Name));
                return;
            }

            serializerPartBuilder.Append($$"""
        totalLen += {{serializerMethod}};
""");
        }

        // C# 11のRaw String Literalを使ってText Template的な置換(便利)
        // ファイルとして書き出される時対策として <auto-generated/> を入れたり
        // nullable enableしつつ、nullable系のwarningがウザいのでdisableして回ったりなどをテンプレコードとして入れておいたりする
        var code = $$"""
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

using System.Buffers;

{{ns}}

partial struct {{typeSymbol.Name}}
{
    /// <summary>
    /// Write this struct self to the IBufferWriter.
    /// </summary>
    public int {{MethodNameToAdd}}(IBufferWriter<byte> writer)
    {
        int total = 0;
        {{serializerPartBuilder}}
        return total;
    }
}
""";
        context.AddSource($"{fullType}.g.cs", code);
    }

    [SuppressMessage("ReSharper", "SwitchExpressionHandlesSomeKnownEnumValuesWithExceptionInDefault")]
    private static string? DetermineFieldSerializerStr(ISymbol fieldOrProp)
    {
        string typeName = fieldOrProp.Kind switch
        {
            SymbolKind.Field    => ((IFieldSymbol)fieldOrProp).Type.Name,
            SymbolKind.Property => ((IPropertySymbol)fieldOrProp).Type.Name,
            _                   => throw new ArgumentException($"Not a suitable kind of symbol : {fieldOrProp.Kind}")
        };

        return typeName switch
        {
            // Numeric subset of IConvertible
            "byte" or "sbyte"
                or "ushort" or "short"
                or "uint" or "int"
                or "ulong" or "long"
                or "double" or "float"
                or "decimal"
                => $"Amf0Writer.WriteNumber(writer, Convert.ToDouble({fieldOrProp.Name}))",
            "bool"
                => $"Amf0Writer.WriteBool(writer, {fieldOrProp.Name})",
            "string"
                => $"Amf0Writer.WriteString(writer, {fieldOrProp.Name})",
            _
                => null
        };
    }
}
